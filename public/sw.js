/**
 * Nebraska Treatment Connect - Service Worker
 *
 * This is a manual service worker for reference or custom use cases.
 * When using Vite + vite-plugin-pwa, this is auto-generated by Workbox.
 *
 * Cache Strategies:
 * - Network First: HTML pages, API calls (get fresh content, fallback to cache)
 * - Cache First: CSS, JS, images, fonts (use cache, rarely changes)
 * - Stale While Revalidate: Static data (serve cached, update in background)
 */

const CACHE_VERSION = 'v1.0.0';
const CACHE_NAMES = {
  static: `static-${CACHE_VERSION}`,
  dynamic: `dynamic-${CACHE_VERSION}`,
  api: `api-${CACHE_VERSION}`,
  images: `images-${CACHE_VERSION}`,
};

// Assets to pre-cache on install
const PRECACHE_ASSETS = [
  '/',
  '/index.html',
  '/detox.html',
  '/halfway-houses.html',
  '/outpatient.html',
  '/privacy.html',
  '/terms.html',
  '/404.html',
  '/static-data.js',
  '/config.js',
];

// Install event - pre-cache static assets
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');

  event.waitUntil(
    caches.open(CACHE_NAMES.static).then((cache) => {
      console.log('[SW] Pre-caching static assets');
      return cache.addAll(PRECACHE_ASSETS);
    })
  );

  // Take control immediately
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');

  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => {
            // Delete caches that don't match current version
            return !Object.values(CACHE_NAMES).includes(name);
          })
          .map((name) => {
            console.log('[SW] Deleting old cache:', name);
            return caches.delete(name);
          })
      );
    })
  );

  // Take control of all pages immediately
  self.clients.claim();
});

// Fetch event - handle requests with appropriate strategy
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Skip Chrome extension requests
  if (url.protocol === 'chrome-extension:') {
    return;
  }

  // API requests - Network First
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(request, CACHE_NAMES.api, 5000));
    return;
  }

  // Static data - Stale While Revalidate
  if (url.pathname.includes('static-data.js')) {
    event.respondWith(staleWhileRevalidate(request, CACHE_NAMES.static));
    return;
  }

  // HTML pages - Network First
  if (request.headers.get('accept')?.includes('text/html')) {
    event.respondWith(networkFirst(request, CACHE_NAMES.dynamic, 3000));
    return;
  }

  // CSS/JS assets - Cache First
  if (
    url.pathname.endsWith('.css') ||
    url.pathname.endsWith('.js') ||
    url.pathname.includes('/assets/')
  ) {
    event.respondWith(cacheFirst(request, CACHE_NAMES.static));
    return;
  }

  // Images - Cache First
  if (
    url.pathname.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/) ||
    url.hostname.includes('fonts.googleapis.com') ||
    url.hostname.includes('fonts.gstatic.com') ||
    url.hostname.includes('cdnjs.cloudflare.com')
  ) {
    event.respondWith(cacheFirst(request, CACHE_NAMES.images));
    return;
  }

  // Default - Network with cache fallback
  event.respondWith(networkFirst(request, CACHE_NAMES.dynamic, 5000));
});

/**
 * Network First Strategy
 * Try network first, fall back to cache if offline or timeout
 */
async function networkFirst(request, cacheName, timeout = 5000) {
  const cache = await caches.open(cacheName);

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    const networkResponse = await fetch(request, { signal: controller.signal });
    clearTimeout(timeoutId);

    if (networkResponse.ok) {
      // Clone and cache the response
      cache.put(request, networkResponse.clone());
    }

    return networkResponse;
  } catch (error) {
    console.log('[SW] Network failed, trying cache:', request.url);
    const cachedResponse = await cache.match(request);

    if (cachedResponse) {
      return cachedResponse;
    }

    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      return cache.match('/404.html');
    }

    throw error;
  }
}

/**
 * Cache First Strategy
 * Try cache first, fetch from network if not cached
 */
async function cacheFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(request);

  if (cachedResponse) {
    return cachedResponse;
  }

  try {
    const networkResponse = await fetch(request);

    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }

    return networkResponse;
  } catch (error) {
    console.log('[SW] Cache and network failed:', request.url);
    throw error;
  }
}

/**
 * Stale While Revalidate Strategy
 * Return cached response immediately, fetch in background to update cache
 */
async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(request);

  // Fetch in background
  const fetchPromise = fetch(request)
    .then((networkResponse) => {
      if (networkResponse.ok) {
        cache.put(request, networkResponse.clone());
      }
      return networkResponse;
    })
    .catch((error) => {
      console.log('[SW] Background fetch failed:', request.url);
    });

  // Return cached response or wait for network
  return cachedResponse || fetchPromise;
}

// Message handler for cache control
self.addEventListener('message', (event) => {
  if (event.data === 'skipWaiting') {
    self.skipWaiting();
  }

  if (event.data === 'clearCache') {
    caches.keys().then((names) => {
      names.forEach((name) => caches.delete(name));
    });
  }

  if (event.data?.type === 'CACHE_URLS') {
    const urls = event.data.urls;
    caches.open(CACHE_NAMES.static).then((cache) => {
      cache.addAll(urls);
    });
  }
});

// Background sync for offline status updates (if needed in future)
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-status-updates') {
    event.waitUntil(syncStatusUpdates());
  }
});

async function syncStatusUpdates() {
  // Placeholder for syncing offline status updates
  console.log('[SW] Syncing offline status updates...');
}
